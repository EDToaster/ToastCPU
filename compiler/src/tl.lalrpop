grammar;

use crate::ast::*;
use crate::parse::*;


pub Identifier: Identifier<'input> = {
    <id:IDENT> => Identifier { id }
}

pub Block: Vec<Statement<'input>> = {
    <block:Statement*> => block,
}

pub Statement: Statement<'input> = {
    // for ( expr ) { }
    CTRL_FOR PL <pre:RawStatement?> SEMI <cond:Expression> SEMI PR CBL <body:Block> CBR => Statement::For(ForStatement { pre: Box::new(pre.unwrap_or(Statement::Empty())), cond, body }),
    <r: RawStatement> SEMI => r,
}

RawStatement: Statement<'input> = {
    <id:Identifier> ASSIGN <expr:Expression> => Statement::Assignment(id, expr),
    PRIM_WORD <id:Identifier> => Statement::Declaration(id),
}

pub Expression: Expression<'input> = {
    Literal => Expression::Literal(<>)
}

pub Literal: Literal<'input> = {
    IntLiteral,
    CharLiteral,
    StringLiteral,
}

IntLiteral: Literal<'input> = {
    <s:LIT_INT_HEX> => Literal::Int(i32::parse_with_prefix(s).unwrap()),
    <s:LIT_INT_BIN> => Literal::Int(i32::parse_with_prefix(s).unwrap()),
    <s:LIT_INT_DEC> => Literal::Int(i32::parse_with_prefix(s).unwrap()),
}

CharLiteral: Literal<'input> = {
    <s:LIT_CHAR> => Literal::Char(s.chars().nth(1).unwrap() as i32)
}

StringLiteral: Literal<'input> = {
    <s:LIT_STRING> => Literal::String(&s[1..s.len() - 1]),
}

match {
    // match newline
    r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"#[^\n\r]*[\n\r]*" => { }, // Skip `# comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
} else {
    // literals
    r"0x[0-9a-fA-F]+" => LIT_INT_HEX,
    r"0b[01]+" => LIT_INT_BIN,
    r"[0-9]+" => LIT_INT_DEC,
    r"'[^']'" => LIT_CHAR,
    r#""[^"]*""# => LIT_STRING,
} else {
    // control flow keywords
    "for" => CTRL_FOR,
    // primitives
    "word" => PRIM_WORD,

    ";" => SEMI,

    // all brackets
    "{" => CBL,
    "}" => CBR,
    
    "[" => SBL,
    "]" => SBR,

    "(" => PL,
    ")" => PR,

    // arith
    "=" => ASSIGN
} else {
    // identifiers
    r"[a-zA-Z_][\w]*" => IDENT,
} else {
    _
}